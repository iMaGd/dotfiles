# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}


# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1");
  origsize=$(( origsize / 1024 ));
    local gzipsize=$(gzip -c "$1" | wc -c);
  gzipsize=$(( gzipsize / 1024 ));
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
    printf "original size: %d KB\n" "$origsize";
    printf "gzipped  size: %d KB (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# UTF-8-encode a string of Unicode symbols
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Get a character’s Unicode code point
function unicode() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified.";
        return 1;
    fi;

    local domain="${1}";
    echo "Testing ${domain}…";
    echo ""; # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
            no_serial, no_sigdump, no_signame, no_validity, no_version");
        echo "Common Name:";
        echo ""; # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
        echo ""; # newline
        echo "Subject Alternative Name(s):";
        echo ""; # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
            | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
        return 0;
    else
        echo "ERROR: Certificate not found.";
        return 1;
    fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
function v() {
    if [ $# -eq 0 ]; then
        vim .;
    else
        vim "$@";
    fi;
}


# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


# shell functions --------------------------------------------------------
function changelogs(){
  git log $1..HEAD --pretty=format:'- %s'
}


# Create and switch to <new directory>
function md(){
    if [ "$1" == "" ]; then
        echo "md <directory-name>";
    else
        if [ ! -d $1 ]; then
            mkdir $1;
            cd $1;
        else
            echo "$1 directory exists";
        fi;
    fi
}


extract () {
  if [ $# -ne 1 ]
  then
    echo "Error: No file specified."
    return 1
  fi
        if [ -f $1 ] ; then
                case $1 in
                        *.tar.bz2) tar xvjf $1   ;;
                        *.tar.gz)  tar xvzf $1   ;;
                        *.bz2)     bunzip2 $1    ;;
                        *.rar)     unrar x $1    ;;
                        *.gz)      gunzip $1     ;;
                        *.tar)     tar xvf $1    ;;
                        *.tbz2)    tar xvjf $1   ;;
                        *.tgz)     tar xvzf $1   ;;
                        *.zip)     unzip $1      ;;
                        *.Z)       uncompress $1 ;;
                        *.7z)      7z x $1       ;;
                        *)         echo "'$1' cannot be extracted via extract" ;;
                esac
        else
                echo "'$1' is not a valid file"
        fi
}


# clone a directory and cd into it
gclone ()
{
    if [ "$1" == "" ]; then
        echo "gclone <git-repo-url>";
    else
        REPONAME=$(basename $1 .git);

        if [ ! -d $REPONAME ]; then
            echo "cloning repo .."
            git clone $1;
            cd $REPONAME;

        else
            echo "[$REPONAME] already exists. Switched to REPO.";
            cd $REPONAME;

            read -p "Check whether local and remote are in sync?[ y(diff), f(fetch), p(pull) ]" -n 1 -r
            echo    # (optional) move to a new line
            if [[ $REPLY =~ ^[YyDd]$ ]]; then
              git diff origin/master;
              git diff origin/develop;
            fi;
            if [[ $REPLY =~ ^[Ff]$ ]]; then
              git fetch --all;
            fi;
            if [[ $REPLY =~ ^[Pp]$ ]]; then
              git pull --all;
            fi;

        fi;
    fi;
}

## Print a horizontal rule
hr () {
   printf "%$(tput cols)s\n"|tr " " "─"}}
}


function list_menu() {
    local -r prompt="$1" outvar="$2" outval="$3"
    # Skip the first 3 arguments and process the rest as key-value pairs
    shift 3

    # Create arrays for display text and values
    local display_texts=() values=()

    # Process arguments as key-value pairs
    while (( $# > 0 )); do
        display_texts+=("$1")
        values+=("$2")
        shift 2
    done

    local cur=0 count=${#display_texts[@]} index=0
    local esc=$(echo -en "\e") # cache ESC as test doesn't allow esc codes
    printf "$prompt\n"
    while true
    do
        # list all options
        index=0
        for o in "${display_texts[@]}"
        do
            if [ "$index" == "$cur" ]
            then echo -e "> \e[42m$o\e[0m" # mark & highlight the current option
            else echo "  $o"
            fi
            (( ++index ))
        done
        read -s -n3 key # wait for user to key in arrows or ENTER
        if [[ $key == $esc[A ]] # up arrow
        then (( cur-- )); (( cur < 0 )) && (( cur = 0 ))
        elif [[ $key == $esc[B ]] # down arrow
        then (( ++cur )); (( cur >= count )) && (( cur = count - 1 ))
        elif [[ $key == "" ]]
        then break
        fi
        echo -en "\e[${count}A" # go up to the beginning to re-render
    done

    # export the selection to the requested output variables
    printf -v $outvar "${display_texts[$cur]}"
    printf -v $outval "${values[$cur]}"
}

# Displays a list menu to connect to a target servers
function connect_to_target() {
    local targets_list=("$@")  # capture array
    local selected_target_key selected_target_value

    list_menu "Choice target:\n" selected_target_key selected_target_value "${targets_list[@]}"
    echo -e "\nConnecting to [${selected_target_key}]: $selected_target_value ..\n"

    eval "$selected_target_value"
}

# Template for Eisenhower Box
eisenhower() {
cat <<EOF
- Urgent:
    - Important (Do)
        - [ ]
        - [ ]

    - NOT Important (Delegate)
        - [ ]
        - [ ]

- NOT Urgent:
    - Important (Schedule)
        - [ ]
        - [ ]

    - NOT Important (Delete!)
        - [ ]
        - [ ]

- Backlog:
        - [ ]
        - [ ]
EOF
}
